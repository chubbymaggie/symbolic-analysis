%\documentclass{beamer}
\documentclass[mathserif,10pt]{beamer}

\usepackage{beamerthemesplit}
\usepackage{graphics}
\usepackage{epsfig}
\usepackage{algorithm}
\usepackage{verbatim}
\usepackage{listings}
\usepackage{framed}
\usepackage{pstricks}
\usepackage{pst-node,pst-tree}
\usepackage{pst-rel-points}
\usepackage{flexiprogram}
\usepackage[UKenglish]{babel}
\usepackage{hyperref}
\usepackage{pst-coil}
\usepackage{color}
\usepackage{epsfig}
\usepackage{tikz}
%\usepackage{multirow}

\usefonttheme{serif}

\newcommand{\cmt}[1]{}
%\noindent

\setcounter{tocdepth}{1}
\lstset{language=[ANSI]C}
\lstset{% general command to set parameter(s)
  basicstyle=\footnotesize\tt, % print whole listing small
    identifierstyle=, % nothing happens
    commentstyle=\color{red}, % white comments
    showstringspaces=false, % no special string spaces
    lineskip=1pt,
    captionpos=b,
    frame=single,
    breaklines=true
      %\insertauthor[width={3cm},center,respectlinebreaks]
}


\setbeamercovered{transparent=50}

\lstset{classoffset=0,
  morekeywords={},keywordstyle=\color{black},
  classoffset=1,
  classoffset=0}% restore default

  \usetheme{CambridgeUS}
  \usecolortheme{dolphin}

  \title[Bug Finding in Pointer Analysis]{Bug Finding in Pointer Analysis}
  \author[]{{\textbf{Theodoros, Sandeep}} }
  \begin{document}

  \begin{frame}
  \titlepage
  \end{frame}
  \usebeamertemplate{mytheme}

  \AtBeginSection[]
{
  \begin{frame}<beamer>
    \frametitle{Outline}
  \tableofcontents[currentsection]
    \end{frame}
}

\defverbatim[colored]\lstI{
\begin{lstlisting}[language=C++,basicstyle=\tiny,keywordstyle=\color{red}]
  int main() {
    int x=1 , y=2;
    int*  p = (int *)malloc(sizeof(int));

    klee_make_symbolic(&x, sizeof(x), "x");
    //klee_make_symbolic(&y, sizeof(y), "y");

    if(0 != x*y) {
      p = (int *)malloc(4);
    } else {
      if(y == 0) {
        p = (int *)malloc(4);
      }
    }
    return *p;
  }

\end{lstlisting}
}

\defverbatim[colored]\lstII{
\begin{lstlisting}[language=C++,basicstyle=\tiny,keywordstyle=\color{red}]
  struct S {
    int x, y; 
  };
  struct S data[] =
  {
    { 1,2 },
    { 3,4 },
  };
  int main(int argc, char** argv) {

  x= 0 ;
  struct S* z;
  
  klee_make_symbolic(&x, sizeof(x), "X");
  klee_assume(x >= 0 &  x <= 1 );
  
  z   = &data[x++];
  ... = z->x ; 

  return 0;
}


\end{lstlisting}
}

\defverbatim[colored]\algoCheckerIII{
\begin{lstlisting}[language=C++,basicstyle=\tiny,keywordstyle=\color{red}]
  1. foreach load instructions
      1.1. base address  = `base address` of the load
      1.2. foreach `pointer` in the same function scope as the load instruction 
          1.2.1. result = mustAlais_OR_mayNOTAlias(`base address`, `pointer`) // Querying the alias analysis.
                1.2.1.1. if result ==  must-alias, check if `base pointer` and 'pointer' points to the same runtime memory object.
                1.2.1.2. if result ==  mayNot-alias, check if `base pointer` and 'pointer' do not points to the same runtime memory object.
                1.2.1.3. Otherwise, continue.
\end{lstlisting}
}

\section{Implementation}
\subsection{Symbolic Execution}
\frame
{
  \frametitle{\subsecname}
  \begin{itemize}
    \item Symbolic execution using klee  
    \item Migration from Klee to Zesti (a variant of klee) 
    \cmt{
      To mitigate the path explosion problem, ZESTI carefully chooses divergent
        paths via two mechanisms: (1) it only diverges close to sensitive
        instructions (memory accesses and divisions.), i.e instructions that
        might contain a bug, and (2) it chooses the divergence points in order
        of increasing distance from the sensitive instruction. The key idea
        behind this approach is to exercise sensitive instructions on slightly
        different paths, with the goal of triggering a bug if the respective
        instructions contain one.  ZESTI identifies sensitive instructions
        dynamically while running the concrete input.  
    } 
  \end{itemize} 
}

\subsection{Checker Logic}
\frame
{
  \frametitle{\subsecname}
  \begin{itemize}
    \item Instrumenting the code to add checks. 
    \item Incorporating the checker logic in zesti.
    \cmt{
    This prevents zesti from interpreting the checker code (as now the checker code will be a part of the symbolic execution engine). 
    With this the run time performance is expected to improve.
      To mitigate the path explosion problem, ZESTI carefully chooses divergent
        paths via two mechanisms: (1) it only diverges close to sensitive
        instructions (memory accesses and divisions.), i.e instructions that
        might contain a bug, and (2) it chooses the divergence points in order
        of increasing distance from the sensitive instruction. The key idea
        behind this approach is to exercise sensitive instructions on slightly
        different paths, with the goal of triggering a bug if the respective
        instructions contain one.  ZESTI identifies sensitive instructions
        dynamically while running the concrete input.  
    } 
  \end{itemize} 
}

\subsection{Checker Logic - Revised}
\frame
{
  \frametitle{\subsecname}
  \algoCheckerIII
}

\subsection{Implicit klee\_assumes}
\frame
{
  \frametitle{\subsecname}
  \lstII
    \cmt{
    Without the klee_assume, the dereference z->x may get resolved to many
      spurious memory objects. But while dealing with pointer analysis results
      we assume that the index of gptr is within bounds and as a result we are
      getting false positives that (The set of allocation sites corresponding
          to the memory object of the load address, z->x) is NOT a subset of
      (Points to allocation sites for the load address z->x) 
    }

}

\subsection{Importance of making a variable symbolic}
\frame
{
  \frametitle{\subsecname}
  \lstI
  \cmt{
    Rather that explicitly making the  inputs of the test program
      symbolic, let klee instrument the code by inserting klee_make_symbolic
      calls. The inputs that we are considering include command line arguments,
      file inputs, globals and variables used to read inputs (for example using
          scanf).
  }

}

\subsection{Which variables to make symbolic}
\frame
{
  \frametitle{\subsecname}
  \begin{itemize}
    \item explicitly specifying which variablies to make symbolic is difficult. 
    \begin{itemize}
      \item Klee Instruments the code by inserting appropriate klee\_make\_symbolic.
      \item Rechability Analysis to figure out candidates.
    \end{itemize}
  \end{itemize}

}


\subsection{Testing}
\frame
{
  \frametitle{\subsecname}

}

\section{Questions?}
\subsection{Questions?}
\frame
{}

\end{document}
