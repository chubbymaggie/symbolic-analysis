/*
 * GlobalValue Relation
 */
GlobalValue(ptr) <- StaticAlloca(ptr, _).

GlobalValue(fptr) <- FunctionDefinition(fptr, _).

/*
 * Assingment Relation
 */
// Assignment through an LLVM pointer assignment equivalent
// instruction/intrinsic
Assign(dest, Context(func), source, Context(func)) <-
  PtrAssign(dest, source, func),
  FuncInContext(func, Context(func)),
  !GlobalValue(source).

Assign(dest, Context(func), source, Context(global)) <-
  PtrAssign(dest, source, func),
  FuncInContext(func, Context(func)),
  GlobalValue(source),
  GlobalContext(Context(global)).

// Assignment through returning from a function
Assign(dest, Context(caller), source, Context(callee)) <-
  CallRet(dest, cs, caller),
  CallGraphEdge(caller, Context(caller), cs, callee, Context(callee)),
  !GlobalValue(source),
  Ret(source, callee).

Assign(dest, Context(caller), source, Context(global)) <-
  CallRet(dest, cs, caller),
  CallGraphEdge(caller, Context(caller), cs, callee, AnyContext),
  GlobalValue(source),
  GlobalContext(Context(global)),
  Ret(source, callee).

// Assignment of formal arguments with call site arguments
Assign(dest, Context(callee), source, Context(caller)) <-
  Formal(dest, pos, callee),
  Actual(source, pos, cs, caller),
  CallGraphEdge(caller, Context(caller), cs, callee, Context(callee)),
  !GlobalValue(source).

Assign(dest, Context(callee), source, Context(global)) <-
  Formal(dest, pos, callee),
  Actual(source, pos, cs, caller),
  CallGraphEdge(caller, AnyContext, cs, callee, Context(callee)),
  GlobalValue(source),
  GlobalContext(Context(global)).

// Assignment through vararg lists accessed by load
Assign(dest, Context(callee), source, Context(caller)) <-
  HasValist(vlst, callee),
  Argc(n, callee),
  Actual(source, pos, cs, caller),
  Integer:Value(n, ni),
  Integer:Value(pos, posi),
  posi > ni,
  CallGraphEdge(caller, Context(caller), cs, callee, Context(callee)),
  !GlobalValue(source),
  !GlobalValue(dest),
  MemLoad(dest, Context(callee), vlstptr, Context(vlstptr)),
  PointsToValist(vlst, vlstptr, Context(vlstptr)).

Assign(dest, Context(callee), source, Context(global)) <-
  HasValist(vlst, callee),
  Argc(n, callee),
  Actual(source, pos, cs, caller),
  Integer:Value(n, ni),
  Integer:Value(pos, posi),
  posi > ni,
  CallGraphEdge(caller, AnyContext, cs, callee, Context(callee)),
  GlobalValue(source),
  !GlobalValue(dest),
  GlobalContext(Context(global)),
  MemLoad(dest, Context(callee), vlstptr, Context(vlstptr)),
  PointsToValist(vlst, vlstptr, Context(vlstptr)).

Assign(dest, Context(global), source, Context(caller)) <-
  HasValist(vlst, callee),
  Argc(n, callee),
  Actual(source, pos, cs, caller),
  Integer:Value(n, ni),
  Integer:Value(pos, posi),
  posi > ni,
  CallGraphEdge(caller, Context(caller), cs, callee, AnyContext),
  !GlobalValue(source),
  GlobalValue(dest),
  GlobalContext(Context(global)),
  MemLoad(dest, Context(global), vlstptr, Context(vlstptr)),
  PointsToValist(vlst, vlstptr, Context(vlstptr)).

Assign(dest, Context(global), source, Context(global)) <-
  HasValist(vlst, callee),
  Argc(n, callee),
  Actual(source, pos, cs, caller),
  Integer:Value(n, ni),
  Integer:Value(pos, posi),
  posi > ni,
  CallGraphEdge(caller, AnyContext, cs, callee, AnyContext),
  GlobalValue(source),
  GlobalValue(dest),
  GlobalContext(Context(global)),
  MemLoad(dest, Context(global), vlstptr, Context(vlstptr)),
  PointsToValist(vlst, vlstptr, Context(vlstptr)).

// Assignment through vararg lists accessed by va_arg
Assign(dest, Context(callee), source, Context(caller)) <-
  HasValist(vlst, callee),
  Argc(n, callee),
  Actual(source, pos, cs, caller),
  Integer:Value(n, ni),
  Integer:Value(pos, posi),
  posi > ni,
  CallGraphEdge(caller, Context(caller), cs, callee, Context(callee)),
  !GlobalValue(source),
  !GlobalValue(vlstptr),
  VaArg(dest, vlstptr, callee),
  PointsTo(Object(obj), _, vlstptr, Context(callee)),
  ObjPointsToValist(Object(obj), vlst).

Assign(dest, Context(callee), source, Context(global)) <-
  HasValist(vlst, callee),
  Argc(n, callee),
  Actual(source, pos, cs, caller),
  Integer:Value(n, ni),
  Integer:Value(pos, posi),
  posi > ni,
  CallGraphEdge(caller, AnyContext, cs, callee, Context(callee)),
  GlobalValue(source),
  !GlobalValue(vlstptr),
  GlobalContext(Context(global)),
  VaArg(dest, vlstptr, callee),
  PointsTo(Object(obj), _, vlstptr, Context(callee)),
  ObjPointsToValist(Object(obj), vlst).

Assign(dest, Context(callee), source, Context(caller)) <-
  HasValist(vlst, callee),
  Argc(n, callee),
  Actual(source, pos, cs, caller),
  Integer:Value(n, ni),
  Integer:Value(pos, posi),
  posi > ni,
  CallGraphEdge(caller, Context(caller), cs, callee, Context(callee)),
  !GlobalValue(source),
  GlobalValue(vlstptr),
  GlobalContext(Context(global)),
  VaArg(dest, vlstptr, callee),
  PointsTo(Object(obj), _, vlstptr, Context(global)),
  ObjPointsToValist(Object(obj), vlst).

Assign(dest, Context(callee), source, Context(global)) <-
  HasValist(vlst, callee),
  Argc(n, callee),
  Actual(source, pos, cs, caller),
  Integer:Value(n, ni),
  Integer:Value(pos, posi),
  posi > ni,
  CallGraphEdge(caller, AnyContext, cs, callee, Context(callee)),
  GlobalValue(source),
  GlobalValue(vlstptr),
  GlobalContext(Context(global)),
  VaArg(dest, vlstptr, callee),
  PointsTo(Object(obj), _, vlstptr, Context(global)),
  ObjPointsToValist(Object(obj), vlst).


/*
 * MemLoad Relation
 */
// Load through an LLVM load equivalent instruction/intrinsic
MemLoad(ptr, Context(func), srcptr, Context(func)) <-
  Load(ptr, srcptr, func),
  FuncInContext(func, Context(func)),
  !GlobalValue(srcptr).

MemLoad(ptr, Context(func), srcptr, Context(global)) <-
  Load(ptr, srcptr, func),
  FuncInContext(func, Context(func)),
  GlobalValue(srcptr),
  GlobalContext(Context(global)).


/*
 * MemStore Relation
 */
// Store through an LLVM store equivalent instruction/intrinsic
MemStore(ptr, Context(func), data, Context(func)) <-
  Store(ptr, data, func),
  FuncInContext(func, Context(func)),
  !GlobalValue(data),
  !GlobalValue(ptr).

MemStore(ptr, Context(func), data, Context(global)) <-
  Store(ptr, data, func),
  FuncInContext(func, Context(func)),
  GlobalValue(data),
  !GlobalValue(ptr),
  GlobalContext(Context(global)).

MemStore(ptr, Context(global), data, Context(func)) <-
  Store(ptr, data, func),
  FuncInContext(func, Context(func)),
  GlobalValue(ptr),
  !GlobalValue(data),
  GlobalContext(Context(global)).

MemStore(ptr, Context(global), data, Context(global)) <-
  Store(ptr, data, func),
  FuncInContext(func, AnyContext),
  GlobalValue(ptr),
  GlobalValue(data),
  GlobalContext(Context(global)).


/*
 * MemCpy Relation
 */
// Copy through an LLVM copy equivalent instruction/intrinsic
MemCpy(to, Context(func), from, Context(func)) <-
  Copy(to, from, func),
  FuncInContext(func, Context(func)),
  !GlobalValue(to),
  !GlobalValue(from).

MemCpy(to, Context(global), from, Context(func)) <-
  Copy(to, from, func),
  FuncInContext(func, Context(func)),
  GlobalValue(to),
  !GlobalValue(from),
  GlobalContext(Context(global)).

MemCpy(to, Context(func), from, Context(global)) <-
  Copy(to, from, func),
  FuncInContext(func, Context(func)),
  !GlobalValue(to),
  GlobalValue(from),
  GlobalContext(Context(global)).

MemCpy(to, Context(global), from, Context(global)) <-
  Copy(to, from, func),
  FuncInContext(func, AnyContext),
  !GlobalValue(to),
  !GlobalValue(from),
  GlobalContext(Context(global)).


/*
 * MemSet Relation
 */
// Memory set through an LLVM memset equivalent instruction/intrinsic
MemSet(ptr, Context(func)) <-
  Set(ptr, func),
  FuncInContext(func, Context(func)),
  !GlobalValue(ptr).

MemSet(ptr, Context(global)) <-
  Set(ptr, func),
  FuncInContext(func, AnyContext),
  GlobalValue(ptr),
  GlobalContext(Context(global)).


/*
 * PointsTo Relation
 */
// PointsTo through assignment
PointsTo(Object(obj), fld, ptr, Context(ptr)) <-
  Assign(ptr, Context(ptr), source, Context(source)),
  PointsTo(Object(obj), fld, source, Context(source)).

// PointsTo through allocation
PointsTo(Record(as,Context(ptr)), epsilon, ptr, Context(ptr)) <-
  Alloca(ptr, as, func),
  EpsilonField(epsilon),
  FuncInContext(func, Context(ptr)).

// PointsTo through static allocation
PointsTo(Record(as,Context(global)), epsilon, ptr, Context(global)) <-
  StaticAlloca(ptr, as),
  EpsilonField(epsilon),
  GlobalContext(Context(global)).

// PointsTo through function definition
PointsTo(Record(func,Context(global)), epsilon, fptr, Context(global)) <-
  FunctionDefinition(fptr, func),
  EpsilonField(epsilon),
  GlobalContext(Context(global)).

// PointsTo through structure indexing with GEP
PointsTo(Object(obj), fld, ptr, Context(func)) <-
  GEP(ptr, baseptr, offs, func),
  FuncInContext(func, Context(func)),
  !GlobalValue(baseptr),
  PointsTo(Object(obj), fld1, baseptr, Context(func)),
  FieldOffset(fld1, offs, fld).

PointsTo(Object(obj), fld, ptr, Context(func)) <-
  GEP(ptr, baseptr, offs, func),
  FuncInContext(func, Context(func)),
  GlobalValue(baseptr),
  GlobalContext(Context(global)),
  PointsTo(Object(obj), fld1, baseptr, Context(global)),
  FieldOffset(fld1, offs, fld).

// PointsTo through structure indexing with GEP into collapsed objects
PointsTo(Object(obj), collapse, ptr, Context(func)) <-
  GEP(ptr, baseptr, _, func),
  FuncInContext(func, Context(func)),
  !GlobalValue(baseptr),
  PointsTo(Object(obj), _, baseptr, Context(func)),
  Collapsed(Object(obj)),
  CollapseField(collapse).

PointsTo(Object(obj), collapse, ptr, Context(func)) <-
  GEP(ptr, baseptr, _, func),
  FuncInContext(func, Context(func)),
  GlobalValue(baseptr),
  GlobalContext(Context(global)),
  PointsTo(Object(obj), _, baseptr, Context(global)),
  Collapsed(Object(obj)),
  CollapseField(collapse).

// PointsTo through memory load
PointsTo(Object(obj), fld, ptr, Context(ptr)) <-
  MemLoad(ptr, Context(ptr), srcptr, Context(srcptr)),
  PointsTo(Object(loadobj), loadfld, srcptr, Context(srcptr)),
  ObjPointsTo(Object(loadobj), loadfld, Object(obj), fld).

// PointsTo through pointing to a collapsed object
PointsTo(Object(obj), collapse, ptr, Context(ptr)) <-
  PointsTo(Object(obj), _, ptr, Context(ptr)),
  Collapsed(Object(obj)),
  CollapseField(collapse).


/*
 * ObjPointsTo Relation
 */
// ObjPointsTo through global variable initialization
ObjPointsTo(Object(obj1), fld1, Object(obj2), fld2) <-
  InitField(fld1, data, as),
  StaticAlloca(ptr, as),
  PointsTo(Object(obj1), epsilon, ptr, Context(global)),
  GlobalContext(Context(global)),
  EpsilonField(epsilon),
  PointsTo(Object(obj2), fld2, data, Context(global)).

// ObjPointsTo through memory store
ObjPointsTo(Object(obj1), fld1, Object(obj2), fld2) <-
  MemStore(ptr, Context(ptr), data, Context(data)),
  PointsTo(Object(obj1), fld1, ptr, Context(ptr)),
  PointsTo(Object(obj2), fld2, data, Context(data)).

// ObjPointsTo through memcpy (copying an entire object)
ObjPointsTo(Object(obj1), fld1, Object(obj2), fld2) <-
  MemCpy(to, Context(to), from, Context(from)),
  PointsTo(Object(obj1), _, to, Context(to)),
  PointsTo(Object(srcobj), _, from, Context(from)),
  ObjPointsTo(Object(srcobj), fld1, Object(obj2), fld2).

// ObjPointsTo through pointing from a collapsed object: the collapse field of
// the object may point to any field that the object points to
ObjPointsTo(Object(obj1), collapse, Object(obj2), fld2) <-
  Collapsed(Object(obj1)),
  CollapseField(collapse),
  ObjPointsTo(Object(obj1), _, Object(obj2), fld2).

// ObjPointsTo through pointing to a collapsed object: the object points to the
// collapse field
ObjPointsTo(Object(obj1), fld1, Object(obj2), collapse) <-
  Collapsed(Object(obj2)),
  CollapseField(collapse),
  ObjPointsTo(Object(obj1), fld1, Object(obj2), _).


/*
 * Rules that handle the fact that the first field of an object also overlaps
 * with epsilon
 */
/*
// If we load from a field that overlaps with epsilon, we also load from
// epsilon
PointsTo(Object(obj), fld, ptr, Context(ptr)) <-
  MemLoad(ptr, Context(ptr), srcptr, Context(srcptr)),
  PointsTo(Object(loadobj), loadfld, srcptr, Context(srcptr)),
  OverlapsWithEpsilon(loadfld),
  EpsilonField(epsilon),
  ObjPointsTo(Object(loadobj), epsilon, Object(obj), fld).

// If we load from epsilon, we also load from the fields that overlap with
// epsilon
PointsTo(Object(obj), fld, ptr, Context(ptr)) <-
  MemLoad(ptr, Context(ptr), srcptr, Context(srcptr)),
  PointsTo(Object(loadobj), epsilon, srcptr, Context(srcptr)),
  EpsilonField(epsilon),
  OverlapsWithEpsilon(loadfld),
  ObjPointsTo(Object(loadobj), loadfld, Object(obj), fld).

// If we store to epsilon, then we also store to the fields that overlap with
// epsilon. Note that we only store to the fields that are accessed by the
// object, otherwise this rule would collapse everything
ObjPointsTo(Object(obj1), fld1, Object(obj2), fld2) <-
  MemStore(ptr, Context(ptr), data, Context(data)),
  PointsTo(Object(obj1), epsilon, ptr, Context(ptr)),
  EpsilonField(epsilon),
  FieldAccessed(fld1, obj1),
  OverlapsWithEpsilon(fld1),
  PointsTo(Object(obj2), fld2, data, Context(data)).

// If we store to a field that overlaps with epsilon, we also store to epsilon
ObjPointsTo(Object(obj1), epsilon, Object(obj2), fld2) <-
  MemStore(ptr, Context(ptr), data, Context(data)),
  PointsTo(Object(obj1), fld1, ptr, Context(ptr)),
  OverlapsWithEpsilon(fld1),
  EpsilonField(epsilon),
  PointsTo(Object(obj2), fld2, data, Context(data)).
*/
PointsTo(Object(obj), fld, ptr, Context(ptr)) <-
  MemLoad(ptr, Context(ptr), srcptr, Context(srcptr)),
  PointsTo(Object(loadobj), loadfld, srcptr, Context(srcptr)),
  SafeCast(loadfld, overlapfld),
  ObjPointsTo(Object(loadobj), overlapfld, Object(obj), fld).

ObjPointsTo(Object(obj1), fld1, Object(obj2), fld2) <-
  MemStore(ptr, Context(ptr), data, Context(data)),
  PointsTo(Object(obj1), fld, ptr, Context(ptr)),
  FieldAccessed(fld1, obj1),
  SafeCast(fld, fld1),
  PointsTo(Object(obj2), fld2, data, Context(data)).


/*
 * PointsToValist relation
 */
// PointsToValist through memory load
PointsToValist(vlst, ptr, Context(ptr)) <-
  MemLoad(ptr, Context(ptr), srcptr, Context(srcptr)),
  PointsTo(Object(obj), _, srcptr, Context(srcptr)),
  ObjPointsToValist(Object(obj), vlst).

// PointsToValist through assignment
PointsToValist(vlst, ptr, Context(ptr)) <-
  Assign(ptr, Context(ptr), source, Context(source)),
  PointsToValist(vlst, source, Context(source)).


/*
 * ObjPointsToValist relation
 */
// ObjPointsToValist through call to llvm.va_start
ObjPointsToValist(Object(obj), vlst) <-
  VaStart(ptr, func),
  HasValist(vlst, func),
  FuncInContext(func, Context(func)),
  !GlobalValue(ptr),
  PointsTo(Object(obj), _, ptr, Context(func)).
  
ObjPointsToValist(Object(obj), vlst) <-
  VaStart(ptr, func),
  HasValist(vlst, func),
  FuncInContext(func, AnyContext),
  GlobalValue(ptr),
  GlobalContext(Context(global)),
  PointsTo(Object(obj), _, ptr, Context(global)).

// ObjPointsToValist through call to llvm.va_copy
ObjPointsToValist(Object(obj), vlst) <-
  VaCopy(to, from, func),
  FuncInContext(func, Context(func)),
  !GlobalValue(to),
  !GlobalValue(from),
  PointsTo(Object(obj), _, to, Context(func)),
  PointsTo(Object(obj2), _, from, Context(func)),
  ObjPointsToValist(Object(obj2), vlst).

ObjPointsToValist(Object(obj), vlst) <-
  VaCopy(to, from, func),
  FuncInContext(func, Context(func)),
  !GlobalValue(to),
  GlobalValue(from),
  GlobalContext(Context(global)),
  PointsTo(Object(obj), _, to, Context(func)),
  PointsTo(Object(obj2), _, from, Context(global)),
  ObjPointsToValist(Object(obj2), vlst).

ObjPointsToValist(Object(obj), vlst) <-
  VaCopy(to, from, func),
  FuncInContext(func, Context(func)),
  GlobalValue(to),
  !GlobalValue(from),
  GlobalContext(Context(global)),
  PointsTo(Object(obj), _, to, Context(global)),
  PointsTo(Object(obj2), _, from, Context(func)),
  ObjPointsToValist(Object(obj2), vlst).

ObjPointsToValist(Object(obj), vlst) <-
  VaCopy(to, from, func),
  FuncInContext(func, AnyContext),
  GlobalValue(to),
  GlobalValue(from),
  GlobalContext(Context(global)),
  PointsTo(Object(obj), _, to, Context(global)),
  PointsTo(Object(obj2), _, from, Context(global)),
  ObjPointsToValist(Object(obj2), vlst).

/*
 * PointsToFunction Relation
 */
PointsToFunction(func, fptr, Context(fptr)) <-
  PointsTo(Object(func_obj), epsilon, fptr, Context(fptr)),
  !GlobalValue(fptr),
  EpsilonField(epsilon),
  func = AllocsiteOf(Object(func_obj)),
  Function(func).

PointsToFunction(func, fptr, Context(global)) <-
  PointsTo(Object(func_obj), epsilon, fptr, Context(global)),
  GlobalValue(fptr),
  GlobalContext(Context(global)),
  EpsilonField(epsilon),
  func = AllocsiteOf(Object(func_obj)),
  Function(func).


/*
 * CallGraphEdge Relation
 */
//FIXME AnyObject should be replaced by the this object.
CallGraphEdge(caller, Context(caller), cs, callee, Merge(cs,AnyObject,Context(caller))) <-
  Call(fptr, cs, caller),
  FuncInContext(caller, Context(caller)),
  PointsToFunction(callee, fptr, Context(caller)).

CallGraphEdge(caller, Context(caller), cs, callee, Merge(cs,AnyObject,Context(caller))) <-
  Call(fptr, cs, caller),
  FuncInContext(caller, Context(caller)),
  PointsToFunction(callee, fptr, Context(global)),
  GlobalContext(Context(global)).

CallGraphEdge(caller, Context(caller), cs, callee, Merge(cs,AnyObject,Context(caller))) <-
  Call(fptr, cs, caller),
  FuncInContext(caller, Context(caller)),
  NoAddressFunctionDefinition(fptr, callee).

// If a function pointer is passed to an external function, then we have to
// assume that the function pointed by the pointer may be called as well
CallGraphEdge(caller, Context(caller), cs, callee, Merge(cs,AnyObject,Context(caller))) <-
  ExternallyVisibleFunction(caller),
  CallGraphEdge(callercaller, Context(callercaller), callercs, caller, Context(caller)),
  Actual(fptr, _, callercs, callercaller),
  PointsToFunction(callee, fptr, Context(callercaller)),
  cs = callercs.

CallGraphEdge(caller, Context(caller), cs, callee, Merge(cs,AnyObject,Context(caller))) <-
  ExternallyVisibleFunction(caller),
  CallGraphEdge(callercaller, AnyContext, callercs, caller, Context(caller)),
  Actual(fptr, _, callercs, callercaller),
  PointsToFunction(callee, fptr, Context(global)),
  GlobalContext(Context(global)),
  cs = callercs.


/*
 * FuncInContext Relation
 */
FuncInContext(func, Context(func)) <-
  StartingPoint(func, Context(func)).

FuncInContext(func, Context(func)) <-
  CallGraphEdge(_, AnyContext, _, func, Context(func)).


/*
 * FieldAccessed Relation
 */
FieldAccessed(fld, Object(obj)) <- PointsTo(Object(obj), fld, _, AnyContext).
FieldAccessed(fld, Object(obj)) <- ObjPointsTo(AnyObject, _, Object(obj), fld).


/*
 * Collapsed Relation
 */
// An object is collapsed if two fields with different base types are accessed
// in the object
Collapsed(Object(obj)) <-
  FieldAccessed(fld1, Object(obj)),
  FieldInType(fld1, t1),
  FieldAccessed(fld2, Object(obj)),
  FieldInType(fld2, t2),
  t1 != t2.

// An object is collapsed if we attempt to access a field that does not exist in
// the object
Collapsed(Object(obj)) <-
  GEP(_, baseptr, offs, func),
  FuncInContext(func, Context(func)),
  PointsTo(Object(obj), fld, baseptr, Context(func)),
  !GlobalValue(baseptr),
  !FieldOffset(fld, offs, _).

Collapsed(Object(obj)) <-
  GEP(_, baseptr, offs, func),
  FuncInContext(func, AnyContext),
  PointsTo(Object(obj), fld, baseptr, Context(global)),
  GlobalValue(baseptr),
  GlobalContext(Context(global)),
  !FieldOffset(fld, offs, _).

// An object is collapsed if it holds a pointer to a Valist object
Collapsed(Object(obj)) <-
  ObjPointsToValist(Object(obj), _).

// An object is collapsed if it is pointed by a pointer passed as argument to
// memmory set
Collapsed(Object(obj)) <-
  MemSet(ptr, Context(ptr)),
  PointsTo(Object(obj), _, ptr, Context(ptr)).

// An object is collapsed if a memcpy call copies an object of different type in
// the first object's memory
Collapsed(Object(obj)) <-
  MemCpy(to, Context(to), from, Context(from)),
  PointsTo(Object(obj), _, to, Context(to)),
  as1 = AllocsiteOf(Object(obj)),
  AllocsiteType(as1, t1),
  PointsTo(Object(srcobj), _, from, Context(from)),
  as2 = AllocsiteOf(Object(srcobj)),
  AllocsiteType(as2, t2),
  t1 != t2.


/*
 * ForcesEscape Relation
 */
// A pointer forces its points-to set to escape if it is an argument of ptrtoint
ForcesEscape(ptr, Context(func)) <-
  PtrToInt(ptr, func),
  FuncInContext(func, Context(func)),
  !GlobalValue(ptr).

ForcesEscape(ptr, Context(global)) <-
  PtrToInt(ptr, func),
  FuncInContext(func, AnyContext),
  GlobalValue(ptr),
  GlobalContext(Context(global)).

// A pointer forces its points-to set to escape if it is passed as a parameter
// to an escaping function
ForcesEscape(ptr, Context(caller)) <-
  Actual(ptr, _, cs, caller),
  CallGraphEdge(caller, Context(caller), cs, callee, AnyContext),
  !GlobalValue(ptr),
  callee = AllocsiteOf(Object(callee_obj)),
  ObjEscapes(Object(callee_obj)).

ForcesEscape(ptr, Context(global)) <-
  Actual(ptr, _, cs, caller),
  CallGraphEdge(caller, AnyContext, cs, callee, AnyContext),
  GlobalValue(ptr),
  GlobalContext(Context(global)),
  callee = AllocsiteOf(Object(callee_obj)),
  ObjEscapes(Object(callee_obj)).

// A pointer forces its points-to set to escape if it is the return value of
// an escaping function
ForcesEscape(ptr, Context(func)) <-
  Ret(ptr, func),
  FuncInContext(func, Context(func)),
  !GlobalValue(ptr),
  func = AllocsiteOf(Object(func_obj)),
  ObjEscapes(Object(func_obj)).

ForcesEscape(ptr, Context(global)) <-
  Ret(ptr, func),
  FuncInContext(func, AnyContext),
  GlobalValue(ptr),
  GlobalContext(Context(global)),
  func = AllocsiteOf(Object(func_obj)),
  ObjEscapes(Object(func_obj)).


/*
 * ObjForcesEscape Relation
 */
// An object's field forces its points-to set to escape if it is loaded as an
// integer
ObjForcesEscape(Object(obj), fld) <-
  IntLoad(ptr, func),
  FuncInContext(func, Context(func)),
  !GlobalValue(ptr),
  PointsTo(Object(obj), fld, ptr, Context(func)).

ObjForcesEscape(Object(obj), fld) <-
  IntLoad(ptr, func),
  FuncInContext(func, AnyContext),
  GlobalValue(ptr),
  GlobalContext(Context(global)),
  PointsTo(Object(obj), fld, ptr, Context(global)).


/*
 * ObjEscapes Relation
 */
// Objects pointed by externally visible global variables and functions belong
// to the escaping set
ObjEscapes(Object(obj)) <-
  ExternallyVisible(ptr),
  PointsTo(Object(obj), _, ptr, AnyContext).

// Objects that belong to the points-to set of a pointer or an object field,
// which forces its points-to set to escape, should be added to the escaping set 
ObjEscapes(Object(obj)) <-
  PointsTo(Object(obj), _, ptr, Context(ptr)),
  ForcesEscape(ptr, Context(ptr)).

ObjEscapes(Object(obj)) <-
  ObjPointsTo(Object(obj1), fld, Object(obj), _),
  ObjForcesEscape(Object(obj1), fld).

// Objects that are pointed by objects already in the escaping set, also belong
// in the escaping set
ObjEscapes(Object(obj)) <-
  ObjEscapes(Object(obj1)),
  ObjPointsTo(Object(obj1), _, Object(obj), _).


/*
 * PointsToExternal Relation
 */
// A pointer points to the escaping set if it points to an escaping object
PointsToExternal(ptr, Context(ptr)) <-
  PointsTo(Object(obj), _, ptr, Context(ptr)),
  ObjEscapes(Object(obj)).

// A pointer may point to the escaping set if it is the result of an inttoptr
// instruction
PointsToExternal(ptr, Context(func)) <-
  IntToPtr(ptr, func),
  FuncInContext(func, Context(func)).

// A pointer may point to the escaping set if it is assigned from a pointer that
// may point to the escaping set 
PointsToExternal(ptr, Context(ptr)) <-
  Assign(ptr, Context(ptr), source, Context(source)),
  PointsToExternal(source, Context(source)).

// A pointer may point to the escaping set if it is the result of a load from an
// object field that may point to the escaping set
PointsToExternal(ptr, Context(ptr)) <-
  MemLoad(ptr, Context(ptr), srcptr, Context(srcptr)),
  PointsTo(Object(loadobj), loadfld, srcptr, Context(srcptr)),
  ObjPointsToExternal(Object(loadobj), loadfld).

// A pointer may point to the escaping set if it is the result of a load from a
// pointer that may point to the escaping set
PointsToExternal(ptr, Context(ptr)) <-
  MemLoad(ptr, Context(ptr), srcptr, Context(srcptr)),
  PointsToExternal(srcptr, Context(srcptr)).

// A pointer may point to the escaping set if it is the result of a GEP from a
// base pointer that may point to the escaping set
PointsToExternal(ptr, Context(func)) <-
  GEP(ptr, baseptr, _, func),
  FuncInContext(func, Context(func)),
  !GlobalValue(baseptr),
  PointsToExternal(baseptr, Context(func)).

PointsToExternal(ptr, Context(func)) <-
  GEP(ptr, baseptr, _, func),
  FuncInContext(func, Context(func)),
  GlobalValue(baseptr),
  GlobalContext(Context(global)),
  PointsToExternal(baseptr, Context(global)).

// A formal argument of a function that is an entry point of the module may
// point to the escaping set
PointsToExternal(ptr, Context(func)) <-
  ExternallyInitializedFormalArg(ptr, func),
  FuncInContext(func, Context(func)).

// A pointer may point to the escaping set if it is a formal argument of an
// escaping function
PointsToExternal(ptr, Context(func)) <-
  Formal(ptr, _, func),
  FuncInContext(func, Context(func)),
  func = AllocsiteOf(Object(func_obj)),
  ObjEscapes(Object(func_obj)).

// A formal argument of a function that is passed as argument to an external
// function call may point to the escaping set
PointsToExternal(ptr, Context(func)) <-
  ExternallyVisibleFunction(caller),
  CallGraphEdge(caller, AnyContext, _, func, Context(func)),
  Formal(ptr, _, func).

// A pointer may point to the escaping set if it is the return value of a call
// to an escaping function
PointsToExternal(ptr, Context(caller)) <-
  CallRet(ptr, cs, caller),
  CallGraphEdge(caller, Context(caller), cs, callee, AnyContext),
  callee = AllocsiteOf(Object(callee_obj)),
  ObjEscapes(Object(callee_obj)).


/*
 * ObjPointsToExternal Relation
 */
// An object field points to the escaping set if it points to an escaping object
ObjPointsToExternal(Object(obj), fld) <-
  ObjPointsTo(Object(obj), fld, Object(obj1), _),
  ObjEscapes(Object(obj1)).

// An object field may point to the escaping set if we store a pointer that may
// point to the escaping set there
ObjPointsToExternal(Object(obj), fld) <-
  MemStore(ptr, Context(ptr), data, Context(data)),
  PointsTo(Object(obj), fld, ptr, Context(ptr)),
  PointsToExternal(data, Context(data)).

// An object field may point to the escaping set if a memcpy operation stored a
// pointer that may point to the escaping set there
ObjPointsToExternal(Object(obj), fld) <-
  MemCpy(to, Context(to), from, Context(from)),
  PointsTo(Object(obj), _, to, Context(to)),
  PointsTo(Object(srcobj), _, from, Context(from)),
  ObjPointsToExternal(Object(srcobj), fld).

// All fields of an object may point to the escaping set if a memcpy operation
// copied an escaping object to the memory of the object
ObjPointsToExternal(Object(obj), fld) <-
  MemCpy(to, Context(to), from, Context(from)),
  PointsTo(Object(obj), _, to, Context(to)),
  PointsToExternal(from, Context(from)),
  FieldAccessed(fld, Object(obj)).

// An object field may point to the escaping set if we store an integer there
ObjPointsToExternal(Object(obj), fld) <-
  IntStore(ptr, func),
  FuncInContext(func, Context(func)),
  !GlobalValue(ptr),
  PointsTo(Object(obj), fld, ptr, Context(func)).

ObjPointsToExternal(Object(obj), fld) <-
  IntStore(ptr, func),
  FuncInContext(func, AnyContext),
  GlobalValue(ptr),
  GlobalContext(Context(global)),
  PointsTo(Object(obj), fld, ptr, Context(global)).


/*
 * We should only output useful points-to relations; ie. ones that do not carry
 * redundant information. There are two sources of redundant information:
 * 1) pointers to collapsed objects may also point to other fields of the same
 * objects, 2) pointers marked as pointing to external code may point to a
 * particular piece of external code
 */

PointsToWithCorrectCollapse(Object(obj), fld, ptr, Context(ptr)) <-
  !Collapsed(Object(obj)),
  PointsTo(Object(obj), fld, ptr, Context(ptr)).

PointsToWithCorrectCollapse(Object(obj), collapse, ptr, Context(ptr)) <-
  Collapsed(Object(obj)),
  CollapseField(collapse),
  PointsTo(Object(obj), _, ptr, Context(ptr)).

UsefulPointsTo(Object(obj), fld, ptr, Context(ptr)) <-
  !PointsToExternal(ptr, Context(ptr)),
  PointsToWithCorrectCollapse(Object(obj), fld, ptr, Context(ptr)).

UsefulPointsTo(Object(obj), fld, ptr, Context(ptr)) <-
  PointsToExternal(ptr, Context(ptr)),
  !ObjEscapes(Object(obj)),
  PointsToWithCorrectCollapse(Object(obj), fld, ptr, Context(ptr)).

ObjPointsToWithCorrectCollapse(Object(obj1), fld1, Object(obj2), fld2) <-
  !Collapsed(Object(obj1)),
  !Collapsed(Object(obj2)),
  ObjPointsTo(Object(obj1), fld1, Object(obj2), fld2).

ObjPointsToWithCorrectCollapse(Object(obj1), collapse, Object(obj2), fld2) <-
  CollapseField(collapse),
  Collapsed(Object(obj1)),
  !Collapsed(Object(obj2)),
  ObjPointsTo(Object(obj1), _, Object(obj2), fld2).

ObjPointsToWithCorrectCollapse(Object(obj1), fld1, Object(obj2), collapse) <-
  CollapseField(collapse),
  !Collapsed(Object(obj1)),
  Collapsed(Object(obj2)),
  ObjPointsTo(Object(obj1), fld1, Object(obj2), _).

ObjPointsToWithCorrectCollapse(Object(obj1), collapse, Object(obj2), collapse) <-
  CollapseField(collapse),
  Collapsed(Object(obj1)),
  Collapsed(Object(obj2)),
  ObjPointsTo(Object(obj1), _, Object(obj2), _).

UsefulObjPointsTo(Object(obj1), fld1, Object(obj2), fld2) <-
  !ObjEscapes(Object(obj1)),
  !ObjPointsToExternal(Object(obj1), fld1),
  ObjPointsToWithCorrectCollapse(Object(obj1), fld1, Object(obj2), fld2).

UsefulObjPointsTo(Object(obj1), fld1, Object(obj2), fld2) <-
  !ObjEscapes(Object(obj1)),
  !ObjEscapes(Object(obj2)),
  ObjPointsToExternal(Object(obj1), fld1),
  ObjPointsToWithCorrectCollapse(Object(obj1), fld1, Object(obj2), fld2).


