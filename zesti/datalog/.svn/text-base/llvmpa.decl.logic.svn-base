/* *
 * *     DOMAINS
 * */

// Integer, represented by its value
Integer(i), Integer:Value(i:v) -> uint[32](v).

// Field, represented by a pointer to a field object
Field(fld), Field:Ptr(fld:p) -> uint[64](p).

// Offset, represented by a pointer to a path string
Offset(offs), Offset:Ptr(offs:p) -> uint[64](p).

// LLVM Value, represented by a pointer to an LLVM value object
LLVMValue(v), LLVMValue:Ptr(v:p) -> uint[64](p).

// Pointers are LLVM Values: a pointer is represented by the LLVM value
// describing the pointer
Pointer(ptr) -> LLVMValue(ptr).
lang:entity(`Pointer).

// Labels are LLVM Values: a label is represented by the LLVM Value of the
// labeled instruction
Label(lbl) -> LLVMValue(lbl).
lang:entity(`Label).

// Callsites are labels: a callsite label refers to a call instruction
Callsite(cs) -> Label(cs).
lang:entity(`Callsite).

// Allocation sites are labels: an allocation site label refers to an
// allocation instruction
Allocsite(as) -> Label(as).
lang:entity(`Allocsite).

// Functions are allocation sites: a function is represented by the allocation
// site label of the function definition
Function(func) -> Allocsite(func).
lang:entity(`Function).

// No address functions are functions which address is never taken
NoAddressFunction(noaddrfunc) -> Function(noaddrfunc).
lang:entity(`NoAddressFunction).

// Valists are LLVM Values: a Valist is represented by the LLVM Value of the
// corresponding vararg function
Valist(vlst) -> LLVMValue(vlst).
lang:entity(`Valist).

// Type, represented by a pointer to an LLVM type object
Type(t), Type:Ptr(t:p) -> uint[64](p).


/* *
 * *  Record, Merge, and AllocsiteOf macro signatures
 * * 
 * *  Record[as, Context(parent)] = Object(new_obj) ->
 * *    Allocsite(as), ContextType(parent), ObjectType(new_obj).
 * * 
 * *  Merge[cs, Object(this_obj), Context(caller)] = Context(callee) ->
 * *    Callsite(cs), ObjectType(this_obj), ContextType(caller),
 * *    ContextType(callee).
 * * 
 * *  AllocsiteOf[Object(obj)] = as -> ObjectType(obj), Allocsite(as).
 * */


/* *
 * *     EDB PREDICATES
 * */

/*
 * GlobalContext Relation
 */
// This means the Context(global) context is the global context: The context in
// which the global variables exist
GlobalContext(Context(global)) -> ContextType(global).


/*
 * StartingPoint Relation
 */
// Every non private function should have a starting context for the analysis
// to procceed
StartingPoint(func, Context(func)) -> Function(func), ContextType(func).


/*
 * EpsilonField Relation
 */
// This is used to identify the epsilon field
EpsilonField(epsilon) -> Field(epsilon).


/*
 * CollapseField Relation
 */
// This is used to identify the collapse field
CollapseField(collapse) -> Field(collapse).


/*
 * OverlapsWithEpsilon Relation
 */
// This relation is used to represent the fact that the epsilon field ovelaps
// with the first field of every object. (Also ovelaps with itself, the collapse
// field, and the scalar field)
OverlapsWithEpsilon(fld) -> Field(fld).


/*
 * SafeCast Relation
 */
// This means that field fld1 and can be used with fld2 base type objects
SafeCast(fld1, fld2) -> Field(fld1), Field(fld2).


/*
 * FieldOffset Relation
 */
// This means that if we begin from field fld1 with offset offs we get to field
// fld2
FieldOffset(fld1, offs, fld2) -> Field(fld1), Offset(offs), Field(fld2).
FieldOffset(fld1, offs, fld21), FieldOffset(fld1, offs, fld22) -> fld21 = fld22.


/*
 * FieldInType Relation
 */
// This means that the field fld has base type t
FieldInType[fld] = t -> Field(fld), Type(t).
FieldInType(fld, t1), FieldInType(fld, t2) -> t1 = t2.


/*
 * Interprocedural Relations
 */
// Represents a formal argument of a function.
//  ptr     : the pointer argument
//  pos     : the position of the pointer argument
//  func    : the function
Formal(ptr, pos, func) -> Pointer(ptr), Integer(pos), Function(func).

// Represents the number of formal arguments of a function.
//  n       : the number of formal arguments
//  func    : the function
Argc(n, func) -> Integer(n), Function(func).

// Indicates whether the function is a vararg
//  vlst    : the Valist object associated with the function
//  func    : the vararg function
HasValist(vlst, func) -> Valist(vlst), Function(func).

// This means the function returns the value ptr.
//  ptr     : return value
//  func    : the function returning the value
Ret(ptr, func) -> Pointer(ptr), Function(func).

// Represents a function call
//  fptr    : pointer to function being called
//  cs      : the callsite label
//  func    : the function containing the call
Call(fptr, cs, func) -> Pointer(fptr), Callsite(cs), Function(func).

// Represents an actual argument in a call site.
//  ptr     : actual pointer argument
//  pos     : position of pointer argument
//  cs      : the callsite label
//  func    : the function containing the call
Actual(ptr, pos, cs, func) ->
 Pointer(ptr), Integer(pos), Callsite(cs), Function(func).

// Represents an llvm.va_start intrinsic
//  ptr     : pointer being passed to llvm.va_start
//  func    : function containing the call to llvm.va_start
VaStart(ptr, func) -> Pointer(ptr), Function(func).

// Represents an llvm.va_copy intrinsic
//  to      : destination pointer being passed to llvm.va_copy
//  from    : source pointer being passed to llvm.va_copy
//  func    : function containing the call to llvm.va_copy
VaCopy(to, from, func) -> Pointer(to), Pointer(from), Function(func).

// Represents an LLVM va_arg instruction
//  ptr     : return value of the va_arg instruction
//  vlstptr : pointer argument of va_arg, it should point to an object that
//            points to the containg function's Valist object
//  func    : function containing the va_arg instruction
VaArg(ptr, vlstptr, func) -> Pointer(ptr), Pointer(vlstptr), Function(func).

// This means the specified variable is the return value of a call site.
//  ptr     : return value
//  cs      : the callsite label
//  func    : the function containing the call
CallRet(ptr, cs, func) -> Pointer(ptr), Callsite(cs), Function(func).


/*
 * Allocation
 */
// This means the specified variable is the result of an allocation.
//  ptr     : pointer to the allocation result
//  as      : the allocation site label
//  func    : the function containing the allocation
Alloca(ptr, as, func) -> Pointer(ptr), Allocsite(as), Function(func).

// This means the specified variable is the result of a static allocation.
//  ptr     : pointer to the static allocation result (a global variable)
//  as      : the allocation site label
StaticAlloca(ptr, as) -> Pointer(ptr), Allocsite(as).

// This is used for a global variable initialization
// fld      : the field being initialized
// data     : the contstant value used for initialization
// as       : the allocation site label for the global variable being
//            initialized
InitField(fld, data, as) -> Field(fld), Pointer(data), Allocsite(as).

// This means that the pointer fptr is defined to point to the function func
// (it is a special static allocation)
FunctionDefinition(fptr, func) -> Pointer(fptr), Function(func).

// This means that the pointer fptr is defined to point to the function
// noaddrfunc, and that this function has not its address taken anywhere in the
// module
NoAddressFunctionDefinition(fptr, noaddrfunc) ->
  Pointer(fptr), NoAddressFunction(noaddrfunc).

// This means the type of objects allocated in alloction site with label as have
// type t
AllocsiteType[as] = t -> Allocsite(as), Type(t).
AllocsiteType(as, t1), AllocsiteType(as, t2) -> t1 = t2.


/*
 * Relations for LLVM Instructions
 */
// This means that there is an assignment to the pointer dest from the pointer
// source in function func
PtrAssign(dest, source, func) -> Pointer(dest), Pointer(source), Function(func).

// This means that there is a load from the pointer srcptr to the pointer ptr in
// function func
Load(ptr, srcptr, func) -> Pointer(ptr), Pointer(srcptr), Function(func).

// This means that there is a store of the pointer data to the pointer ptr in
// function func
Store(ptr, data, func) -> Pointer(ptr), Pointer(data), Function(func).

// This means that the pointer ptr is assigned from a getelementptr instruction
// with the baseprt pointer as base, and the offs offset as offset in function
// func
GEP(ptr, baseptr, offs, func) ->
  Pointer(ptr), Pointer(baseptr), Offset(offs), Function(func).

// This means that there is a copy of the memory pointed by the pointer from to
// the memory pointed by the pointer to in function func
Copy(to, from, func) -> Pointer(to), Pointer(from), Function(func).

// This means that there is a memory set of the memory pointed by the pointer
// ptr in function func
Set(ptr, func) -> Pointer(ptr), Function(func).


/*
 * Realtions for external code handling
 */
// This means there is a ptrtoint instruction with the pointer ptr as argument
// in function func
PtrToInt(ptr, func) -> Pointer(ptr), Function(func).

// This means there is an inttoptr instruction with the pointer ptr as the
// result in function func
IntToPtr(ptr, func) -> Pointer(ptr), Function(func).

// This means there is an integer load instruction with the pointer ptr as
// argument in function func
IntLoad(ptr, func) -> Pointer(ptr), Function(func).

// This means there is an integer store instruction with the pointer ptr as
// argument in function func
IntStore(ptr, func) -> Pointer(ptr), Function(func).

// This means that the pointer ptr points to objects that are visible from
// external code (e.g. pointers to declared functions or global variables)
ExternallyVisible(ptr) -> Pointer(ptr).

// This means that the function func is externally visible.
ExternallyVisibleFunction(func) -> Function(func).
ExternallyVisibleFunction(func) -> ExternallyVisible(func).

// This means that the pointer ptr is a formal argument of a function func that
// is an entry point to the module
ExternallyInitializedFormalArg(ptr, func) -> Pointer(ptr), Function(func).


/* *
 * *     IDB PREDICATES
 * */

/*
 * GlobalValue Relation
 */
// This means the pointer ptr is a global value (global variable or function).
// The only context related with global values should be the global context.
// Remember that global values, cannot be re-assigned in LLVM (only
// initialization is allowed)
GlobalValue(ptr) -> Pointer(ptr).


/*
 * Assingment Relation
 */
// This means the pointer source is assigned to the pointer dest: dest = source
Assign(dest, Context(dest), source, Context(source)) ->
  Pointer(dest), ContextType(dest), Pointer(source), ContextType(source).


/*
 * MemLoad Relation
 */
// This means the contents of pointer srcptr are loaded to pointer ptr:
// ptr = *srcptr
MemLoad(ptr, Context(ptr), srcptr, Context(srcptr)) ->
  Pointer(ptr), ContextType(ptr), Pointer(srcptr), ContextType(srcptr).


/*
 * MemStore Relation
 */
// This means the pointer data is stored in the memory pointed by pointer ptr:
// *ptr = data
MemStore(ptr, Context(ptr), data, Context(data)) ->
  Pointer(ptr), ContextType(ptr), Pointer(data), ContextType(data).


/*
 * MemCpy Relation
 */
// This means that the memory pointed by pointer from is copied to the memory
// pointed by pointer to
MemCpy(to, Context(to), from, Context(from)) ->
  Pointer(to), ContextType(to), Pointer(from), ContextType(from).


/*
 * MemSet Relation
 */
// This means that the memory pointed by pointer ptr is set to some value
MemSet(ptr, Context(ptr)) -> Pointer(ptr), ContextType(ptr).


/*
 * PointsTo Relation
 */
// This means the pointer ptr in context Context(ptr) points to the field fld of
// object Object(obj)
PointsTo(Object(obj), fld, ptr, Context(ptr)) ->
  ObjectType(obj), Field(fld), Pointer(ptr), ContextType(ptr).


/*
 * ObjPointsTo Relation
 */
// This means the field fld1 of object Object(obj1) points to the field fld2 of
// object Object(obj2)
ObjPointsTo(Object(obj1), fld1, Object(obj2), fld2) ->
  ObjectType(obj1), Field(fld1), ObjectType(obj2), Field(fld2).


/*
 * PointsToValist relation
 */
// This means the pointer ptr in context Context(ptr) points to the vlst Valist
// object
PointsToValist(vlst, ptr, Context(ptr)) ->
  Valist(vlst), Pointer(ptr), ContextType(ptr).


/*
 * ObjPointsToValist relation
 */
// This means that the Object(obj) object holds a pointer to the vlst Valist
// object
ObjPointsToValist(Object(obj), vlst) -> ObjectType(obj), Valist(vlst).


/*
 * PointsToFunction Relation
 */
// This means that the fptr pointer points to the function func
PointsToFunction(func, fptr, Context(fptr)) ->
  Function(func), Pointer(fptr), ContextType(fptr).


/*
 * CallGraphEdge Relation
 */
// This means there is a call from function caller in context Context(caller)
// to function callee in context Context(callee), through the callsite cs
CallGraphEdge(caller, Context(caller), cs, callee, Context(callee)) ->
  Function(caller), ContextType(caller), Function(callee), ContextType(callee),
  Callsite(cs).


/*
 * FuncInContext Relation
 */
// This means the function func is reachable in the context Context(func)
FuncInContext(func, Context(func)) -> Function(func), ContextType(func).


/*
 * FieldAccessed Relation
 */
// Determines which fields of an object are accessed.
FieldAccessed(fld, Object(obj)) -> Field(fld), ObjectType(obj).


/*
 * Collapsed Relation
 */
// This means the object Object(obj) has been collapsed
Collapsed(Object(obj)) -> ObjectType(obj).


/*
 * ForcesEscape Relation
 */
// This means the points-to set of the pointer ptr should be added to the
// escaping set (set of objects that are accessible form external code)
ForcesEscape(ptr, Context(ptr)) -> Pointer(ptr), ContextType(ptr).


/*
 * ObjForcesEscape Relation
 */
// This means the points-to set of the fld field of the object Object(obj)
// should be added to the escaping set (set of objects that are accessible
// form external code)
ObjForcesEscape(Object(obj), fld) -> ObjectType(obj), Field(fld).


/*
 * ObjEscapes Relation
 */
// This means that the object Object(obj) belongs to the escaping set, meaning
// that it is accessible from external code)
ObjEscapes(Object(obj)) -> ObjectType(obj).


/*
 * PointsToExternal Relation
 */
// This means that the pointer ptr may point to external locations
PointsToExternal(ptr, Context(ptr)) -> Pointer(ptr), ContextType(ptr).


/*
 * ObjPointsToExternal Relation
 */
// This means that the fld field of the object Object(obj) may contain a pointer
// to an external location
ObjPointsToExternal(Object(obj),  fld) -> ObjectType(obj), Field(fld).


/*
 * We should only output useful points-to relations; ie. ones that do not carry
 * redundant information. There are two sources of redundant information:
 * 1) pointers to collapsed objects may also point to other fields of the same
 * objects, 2) pointers marked as pointing to external code may point to a
 * particular piece of external code
 */
PointsToWithCorrectCollapse(Object(obj), fld, ptr, Context(ptr)) ->
  ObjectType(obj), Field(fld), Pointer(ptr), ContextType(ptr).
UsefulPointsTo(Object(obj), fld, ptr, Context(ptr)) ->
  ObjectType(obj), Field(fld), Pointer(ptr), ContextType(ptr).
ObjPointsToWithCorrectCollapse(Object(obj1), fld1, Object(obj2), fld2) ->
  ObjectType(obj1), Field(fld1), ObjectType(obj2), Field(fld2).
UsefulObjPointsTo(Object(obj1), fld1, Object(obj2), fld2) ->
  ObjectType(obj1), Field(fld1), ObjectType(obj2), Field(fld2).



